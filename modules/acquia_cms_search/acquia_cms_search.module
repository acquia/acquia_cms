<?php

/**
 * @file
 * Contains hook implementations for Acquia CMS Search.
 */

use Drupal\acquia_cms_search\Facade\AcquiaSearchFacade;
use Drupal\acquia_cms_search\Facade\FacetFacade;
use Drupal\acquia_cms_search\Facade\SearchFacade;
use Drupal\acquia_cms_search\Plugin\views\query\SearchApiQuery;
use Drupal\acquia_search\Helper\Runtime;
use Drupal\Core\Config\FileStorage;
use Drupal\Core\DestructableInterface;
use Drupal\field\FieldConfigInterface;
use Drupal\node\NodeTypeInterface;
use Drupal\search_api\Entity\Index;
use Drupal\search_api\ServerInterface;
use Drupal\views\Entity\View;

/**
 * Implements hook_views_data().
 */
function acquia_cms_search_views_data() {
  return [
    'views' => [
      'view_fallback' => [
        'title' => t('Fallback view area'),
        'help' => t('Insert a view inside an area if the search server is unavailable. If the view is not based on a Search API index, this behaves like a standard view area.'),
        'area' => [
          'id' => 'view_fallback',
        ],
      ],
    ],
  ];
}

/**
 * Implements hook_views_plugins_query_alter().
 */
function acquia_cms_search_views_plugins_query_alter(array &$definitions) {
  if (Drupal::moduleHandler()->moduleExists('facets_pretty_paths')) {
    $definitions['search_api_query']['class'] = SearchApiQuery::class;
  }
}

/**
 * Implements hook_views_plugins_cache_alter().
 */
function acquia_cms_search_views_plugins_cache_alter(&$definitions) {
  // This hook was implemented to provide backward compatibility for an issue
  // that was fixed in search_api:8.x-1.32. A new views_cache plugin was,
  // introduced, and accordingly, views configurations were updated. However,
  // this change causes issues with Drupal Core 9.x because the release
  // were new plugin was introduced doesn't support Drupal Core 9.x.
  // @see https://www.drupal.org/project/search_api/issues/3423063.
  // @todo Remove this & SearchApiNoneCacheBC, after we drop CORE 9.x support.
  if (!isset($definitions['search_api_none'])) {
    $definitions['search_api_none_bc']['id'] = 'search_api_none';
    $definitions['search_api_none'] = $definitions['search_api_none_bc'];
  }
  unset($definitions['search_api_none_bc']);
}

/**
 * Implements hook_ENTITY_TYPE_insert() for node types.
 */
function acquia_cms_search_node_type_insert(NodeTypeInterface $node_type) {
  Drupal::classResolver(SearchFacade::class)->addNodeType($node_type);
  if (!$node_type->isSyncing()) {
    _acquia_cms_search_add_category_facet();
  }
  _acquia_cms_search_import_content_type_views($node_type);
}

/**
 * Implements hook_ENTITY_TYPE_insert() for node types.
 */
function acquia_cms_search_node_type_update(NodeTypeInterface $node_type) {
  Drupal::classResolver(SearchFacade::class)->addNodeType($node_type);
  if (!$node_type->isSyncing()) {
    _acquia_cms_search_add_category_facet();
  }
  _acquia_cms_search_import_content_type_views($node_type);
}

/**
 * Implements hook_ENTITY_TYPE_insert() for configurable field.
 */
function acquia_cms_search_field_config_insert(FieldConfigInterface $field_config) {
  /** @var \Drupal\Core\Field\FieldConfigBase $field_storage */
  $field_storage = $field_config->getFieldStorageDefinition();

  // Adding the third party settings in the node.body storage configuration to
  // index the body field for searching.
  if ($field_storage->getType() === 'entity_reference' && $field_storage->getSetting('target_type') === 'taxonomy_term') {
    Drupal::classResolver(SearchFacade::class)->addTaxonomyField($field_storage);
  }

  // List of fields type which needs to be indexed.
  $allowed_fields_type = [
    'datetime',
    'string',
    'email',
    'telephone',
    'address',
    'text_with_summary',
  ];

  // Index allowed fields type.
  if (in_array($field_storage->getType(), $allowed_fields_type)) {
    Drupal::classResolver(SearchFacade::class)->addFields($field_storage);
  }

  // Insert view on config import.
  $configs = [
    'node.article.field_article_type' => 'article',
    'node.event.field_event_type' => 'event',
    'node.person.field_person_type' => 'person',
    'node.place.field_place_type' => 'place',
  ];
  if (in_array($field_config->id(), array_keys($configs))) {
    _acquia_cms_search_import_content_type_views(\Drupal::entityTypeManager()->getStorage('node_type')->load($configs[$field_config->id()]));
  }
}

/**
 * Implements hook_entity_insert().
 */
function acquia_cms_search_entity_insert() {
  // Normally, content is indexed immediately after it is created or modified,
  // at the end of the current request. But that means content created
  // programmatically (i.e., in the PHPUnit tests) are not being indexed. So,
  // explicitly invoke the indexer whenever an entity is created.
  $indexer = Drupal::service('search_api.post_request_indexing');
  if ($indexer instanceof DestructableInterface) {
    $indexer->destruct();
  }
}

/**
 * Import views for content types.
 */
function _acquia_cms_search_import_content_type_views(NodeTypeInterface $node_type){
  $content_views = [
    'article' => 'articles',
    'event' => 'events',
    'person' => 'people',
    'place' => 'places',
  ];
  if(!in_array($node_type->id(), array_keys($content_views))) {
    return;
  }
  // Load the view.
  $view = View::load($content_views[$node_type->id()]);
  if (!$view) {
    // import the view.
    $source = new FileStorage(__DIR__ . '/config/optional');
    $entity_storage = \Drupal::entityTypeManager()->getStorage('view');
    $view_config = $source->read('views.view.' . $content_views[$node_type->id()]);
    // Validate dependencies exist.
    if (!empty($view_config['dependencies'])) {
      $module_handler = \Drupal::service('module_handler');
      foreach ($view_config['dependencies']['module'] as $dependency) {
        if (!$module_handler->moduleExists($dependency)) {
          return;
        }
      }
      foreach ($view_config['dependencies']['config'] as $dependency) {
        if (!configExists($dependency)) {
          return;
        }
      }
    }

    // Create the view entity.
    $entity = $entity_storage->createFromStorageRecord($view_config);
    $entity->save();
  }
}

/**
 * Check if a configuration exists.
 *
 * @param string $config_name
 *   The name of the configuration to check.
 *
 * @return bool
 *   TRUE if the configuration exists, FALSE otherwise.
 */
function configExists($config_name) {
  $config_factory = \Drupal::service('config.factory');
  return $config_factory->get($config_name)->isNew() === FALSE;
}

/**
 * Implements hook_ENTITY_TYPE_insert() for Search API servers.
 */
function acquia_cms_search_search_api_server_insert(ServerInterface $server) {
  // We don't want to do any secondary config writes during a config sync,
  // since that can have major, unintentional side effects.
  if (Drupal::isConfigSyncing()) {
    return;
  }

  // Look for an index which is disabled, but wants to passively opt into using
  // this server.
  $indexes = Index::loadMultiple();
  /** @var \Drupal\search_api\IndexInterface $index */
  foreach ($indexes as $index) {
    if ($index->status() || $index->isServerEnabled()) {
      continue;
    }

    // If the index wants to opt into using this server, grant its wish.
    $server_name = $index->getThirdPartySetting('acquia_cms_search', 'search_server');
    if ($server_name && $server->id() === $server_name) {
      $index->setServer($server)
        ->enable()
        // The third-party setting is only needed once.
        ->unsetThirdPartySetting('acquia_cms_search', 'search_server')
        ->save();
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function acquia_cms_search_search_api_server_update(ServerInterface $entity) {
  if (Drupal::moduleHandler()->moduleExists('acquia_search') && Runtime::isAcquiaServer($entity)) {
    \Drupal::classResolver(AcquiaSearchFacade::class)->submitSettingsForm();
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function acquia_cms_search_form_acquia_cms_search_form_alter(array &$form) {
  $form['#submit'][] = AcquiaSearchFacade::class . '::submitSettingsForm';
}

/**
 * Adds search_category facet, if any acms search dependent module is installed.
 */
function _acquia_cms_search_add_category_facet() {
  $search_category = \Drupal::entityTypeManager()->getStorage('facets_facet')->loadByProperties(['id' => 'search_category']);
  if (!$search_category) {
    \Drupal::classResolver(FacetFacade::class)->addFacet([
      'id' => 'search_category',
      'name' => 'Category',
      'url_alias' => 'category',
      'field_identifier' => 'field_categories',
    ]);
  }
}
